{
	"id": "4dd6eb67e8a2b6a173d5b6234b8b3405",
	"_format": "hh-sol-build-info-1",
	"solcVersion": "0.8.17",
	"solcLongVersion": "0.8.17+commit.8df45f5f",
	"input": {
		"language": "Solidity",
		"sources": {
			"Tokeny Project/Compliance/Compliance Rules/RulesCompliance.sol": {
				"content": "// // SPDX-License-Identifier: MIT\r\n// pragma solidity ^0.8.17;\r\n\r\n// import \"./Compliance.sol\";\r\n\r\n// abstract contract RulesCompliance is Compliance {\r\n\r\n\r\n// //Mappings\r\n//     mapping(uint256 => bool) private _restrictedCountries;\r\n//     mapping(uint256 => bool) private _whitelistedCountries;\r\n//     mapping(address => TransferCounter) public usersCounters;\r\n//     mapping (address => uint256) public IDBalance;\r\n    \r\n//     /// Mapping for wallets tagged as exchange wallets\r\n//     mapping(address => bool) private _exchangeIDs;\r\n//     /// Mapping for users Counters\r\n//     mapping(address => mapping(address => ExchangeTransferCounter)) private _exchangeCounters;\r\n//     /// Getter for Tokens monthlyLimit\r\n//     mapping(address => uint256) private _exchangeMonthlyLimit;\r\n\r\n   \r\n// // STRUCTS\r\n//     struct TransferCounter {\r\n//         uint256 dailyCount;\r\n//         uint256 monthlyCount;\r\n//         uint256 dailyTimer;\r\n//         uint256 monthlyTimer;\r\n//     }\r\n\r\n//     struct ExchangeTransferCounter {\r\n//         uint256 monthlyCount;\r\n//         uint256 monthlyTimer;\r\n//     }\r\n\r\n// //Global Variable\r\n//     uint256 public dailyLimit;\r\n//     uint256 public monthlyLimit;\r\n//     uint256 public maxBalance;\r\n//     uint256 public supplyLimit;\r\n\r\n\r\n// //CountryRestrictions Events\r\n//     event AddedRestrictedCountry(uint256 _country);\r\n//     event RemovedRestrictedCountry(uint256 _country);\r\n\r\n\r\n// //WhitelistCountry events\r\n//     event WhitelistedCountry(uint256 _country);\r\n//     event UnWhitelistedCountry(uint256 _country);\r\n\r\n// //DayMonthLimit events\r\n//     event DailyLimitUpdated(uint _newDailyLimit);\r\n//     event MonthlyLimitUpdated(uint _newMonthlyLimit);\r\n\r\n// //ExchangeMonthlyLimits events\r\n//     event ExchangeMonthlyLimitUpdated(address _exchangeID, uint _newExchangeMonthlyLimit);\r\n//     event ExchangeIDAdded(address _newExchangeID);\r\n//     event ExchangeIDRemoved(address _exchangeID);\r\n\r\n// //MaxBalance event\r\n//     event MaxBalanceSet(uint256 _maxBalance);\r\n\r\n// //SuppliLimit events\r\n//     event SupplyLimitSet(uint256 _limit);\r\n\r\n\r\n//     function batchRestrictCountries(uint256[] calldata _countries) external {\r\n//         for (uint i = 0; i < _countries.length; i++) {\r\n//             addCountryRestriction(_countries[i]);\r\n//         }\r\n//     }\r\n\r\n//     function batchUnrestrictCountries(uint256[] calldata _countries) external {\r\n//         for (uint i = 0; i < _countries.length; i++) {\r\n//             removeCountryRestriction(_countries[i]);\r\n//         }\r\n//     }\r\n\r\n//     function addCountryRestriction(uint256 _country) public onlyOwner {\r\n//         require(!_restrictedCountries[_country], \"country already restricted\");\r\n//         _restrictedCountries[_country] = true;\r\n//         emit AddedRestrictedCountry(_country);\r\n//     }\r\n\r\n//     function removeCountryRestriction(uint256 _country) public onlyOwner {\r\n//         require(_restrictedCountries[_country], \"country not restricted\");\r\n//         _restrictedCountries[_country] = false;\r\n//         emit RemovedRestrictedCountry(_country);\r\n//     }\r\n\r\n//     function isCountryRestricted(uint256 _country) public view returns (bool) {\r\n//         return (_restrictedCountries[_country]);\r\n//     }\r\n\r\n\r\n//     function complianceCheckOnCountryRestrictions (address /*_from*/, address _to, uint256 /*_value*/)\r\n//     public view returns (bool) {\r\n//         uint256 receiverCountry = _getCountry(_to);\r\n//         if (isCountryRestricted(receiverCountry)) {\r\n//             return false;\r\n//         }\r\n//         return true;\r\n//     }\r\n\r\n//     function _transferActionOnCountryRestrictions(address _from, address _to, uint256 _value) internal {}\r\n\r\n//     function _creationActionOnCountryRestrictions(address _to, uint256 _value) internal {}\r\n\r\n//     function _destructionActionOnCountryRestrictions(address _from, uint256 _value) internal {}\r\n\r\n    \r\n// //WhitelistingCountry Functions\r\n\r\n//     function batchWhitelistCountries(uint256[] memory _countries) external {\r\n//         for (uint i = 0; i < _countries.length; i++) {\r\n//             whitelistCountry(_countries[i]);\r\n//         }\r\n//     }\r\n\r\n//     function batchUnWhitelistCountries(uint256[] memory _countries) external {\r\n//         for (uint i = 0; i < _countries.length; i++) {\r\n//             unWhitelistCountry(_countries[i]);\r\n//         }\r\n//     }\r\n\r\n//     function whitelistCountry(uint256 _country) public onlyOwner {\r\n//         require(!_whitelistedCountries[_country], \"country already whitelisted\");\r\n//         _whitelistedCountries[_country] = true;\r\n//         emit WhitelistedCountry(_country);\r\n//     }\r\n\r\n//     function unWhitelistCountry(uint256 _country) public onlyOwner {\r\n//         require(_whitelistedCountries[_country], \"country not whitelisted\");\r\n//         _whitelistedCountries[_country] = false;\r\n//         emit UnWhitelistedCountry(_country);\r\n//     }\r\n\r\n//     function isCountryWhitelisted(uint256 _country) public view returns (bool) {\r\n//         return (_whitelistedCountries[_country]);\r\n//     }\r\n\r\n//     function complianceCheckOnCountryWhitelisting (address /*_from*/, address _to, uint256 /*_value*/)\r\n//     public view returns (bool) {\r\n//         uint256 receiverCountry = _getCountry(_to);\r\n//         if (isCountryWhitelisted(receiverCountry)) {\r\n//             return true;\r\n//         }\r\n//         return false;\r\n//     }\r\n\r\n//     function _transferActionOnCountryWhitelisting(address _from, address _to, uint256 _value) internal {}\r\n\r\n//     function _creationActionOnCountryWhitelisting(address _to, uint256 _value) internal {}\r\n\r\n//     function _destructionActionOnCountryWhitelisting(address _from, uint256 _value) internal {}\r\n\r\n// //DayMonthLimit Functions\r\n\r\n//     function setMonthlyLimit(uint256 _newMonthlyLimit) external onlyOwner {\r\n//         monthlyLimit = _newMonthlyLimit;\r\n//         emit MonthlyLimitUpdated(_newMonthlyLimit);\r\n//     }\r\n\r\n//     function complianceCheckOnDayMonthLimits(address _from, address /*_to*/, uint256 _value) public view returns (bool) {\r\n//         address senderIdentity = _getIdentity(_from);\r\n//         if (!isTokenAgent(_from)) {\r\n//             if (_value > dailyLimit) {\r\n//                 return false;\r\n//             }\r\n//             if (!_isDayFinished(senderIdentity) &&\r\n//             ((usersCounters[senderIdentity].dailyCount + _value > dailyLimit)\r\n//             || (usersCounters[senderIdentity].monthlyCount + _value > monthlyLimit))) {\r\n//                 return false;\r\n//             }\r\n//             if (_isDayFinished(senderIdentity) && _value + usersCounters[senderIdentity].monthlyCount > monthlyLimit) {\r\n//                 return(_isMonthFinished(senderIdentity));\r\n//             }\r\n//         }\r\n//         return true;\r\n//     }\r\n\r\n//     function _transferActionOnDayMonthLimits(address _from, address /*_to*/, uint256 _value) internal {\r\n//         _increaseCounters(_from, _value);\r\n//     }\r\n\r\n//     function _creationActionOnDayMonthLimits(address _to, uint256 _value) internal {}\r\n\r\n//     function _destructionActionOnDayMonthLimits(address _from, uint256 _value) internal {}\r\n\r\n//     function _increaseCounters(address _userAddress, uint256 _value) internal {\r\n//         address identity = _getIdentity(_userAddress);\r\n//         _resetDailyCooldown(identity);\r\n//         _resetMonthlyCooldown(identity);\r\n//         if ((usersCounters[identity].dailyCount + _value) <= dailyLimit) {\r\n//             usersCounters[identity].dailyCount += _value;\r\n//         }\r\n//         if ((usersCounters[identity].monthlyCount + _value) <= monthlyLimit) {\r\n//             usersCounters[identity].monthlyCount += _value;\r\n//         }\r\n//     }\r\n\r\n//     function _resetDailyCooldown(address _identity) internal {\r\n//         if (_isDayFinished(_identity)) {\r\n//             usersCounters[_identity].dailyTimer = block.timestamp + 1 days;\r\n//             usersCounters[_identity].dailyCount = 0;\r\n//         }\r\n//     }\r\n\r\n//     function _resetMonthlyCooldown(address _identity) internal {\r\n//         if (_isMonthFinished(_identity)) {\r\n//             usersCounters[_identity].monthlyTimer = block.timestamp + 30 days;\r\n//             usersCounters[_identity].monthlyCount = 0;\r\n//         }\r\n//     }\r\n\r\n//     function _isDayFinished(address _identity) internal view returns (bool) {\r\n//         return (usersCounters[_identity].dailyTimer <= block.timestamp);\r\n//     }\r\n\r\n//     function _isMonthFinished(address _identity) internal view returns (bool) {\r\n//         return (usersCounters[_identity].monthlyTimer <= block.timestamp);\r\n//     }\r\n\r\n\r\n// //ExchangeMonthlyLimits functions\r\n\r\n//     function setExchangeMonthlyLimit(address _exchangeID, uint256 _newExchangeMonthlyLimit) external onlyOwner {\r\n//         _exchangeMonthlyLimit[_exchangeID] = _newExchangeMonthlyLimit;\r\n//         emit ExchangeMonthlyLimitUpdated(_exchangeID, _newExchangeMonthlyLimit);\r\n//     }\r\n\r\n//     function addExchangeID(address _exchangeID) public onlyOwner {\r\n//         require(!isExchangeID(_exchangeID), \"ONCHAINID already tagged as exchange\");\r\n//         _exchangeIDs[_exchangeID] = true;\r\n//         emit ExchangeIDAdded(_exchangeID);\r\n//     }\r\n\r\n//     function removeExchangeID(address _exchangeID) public onlyOwner {\r\n//         require(isExchangeID(_exchangeID), \"ONCHAINID not tagged as exchange\");\r\n//         _exchangeIDs[_exchangeID] = false;\r\n//         emit ExchangeIDRemoved(_exchangeID);\r\n//     }\r\n\r\n//     function isExchangeID(address _exchangeID) public view returns (bool){\r\n//         return _exchangeIDs[_exchangeID];\r\n//     }\r\n\r\n//     function getMonthlyCounter(address _exchangeID, address _investorID) public view returns (uint256) {\r\n//         return (_exchangeCounters[_exchangeID][_investorID]).monthlyCount;\r\n//     }\r\n\r\n//     function getMonthlyTimer(address _exchangeID, address _investorID) public view returns (uint256) {\r\n//         return (_exchangeCounters[_exchangeID][_investorID]).monthlyTimer;\r\n//     }\r\n\r\n//     function getExchangeMonthlyLimit(address _exchangeID) public view returns (uint256) {\r\n//         return _exchangeMonthlyLimit[_exchangeID];\r\n//     }\r\n\r\n//     function complianceCheckOnExchangeMonthlyLimits(address _from, address _to, uint256 _value) public view returns\r\n//     (bool) {\r\n//         address senderIdentity = _getIdentity(_from);\r\n//         address receiverIdentity = _getIdentity(_to);\r\n//         if (!isTokenAgent(_from) && _from != address(0)) {\r\n//             if (isExchangeID(receiverIdentity)) {\r\n//                 if(_value > _exchangeMonthlyLimit[receiverIdentity]) {\r\n//                     return false;\r\n//                 }\r\n//                 if (!_isExchangeMonthFinished(receiverIdentity, senderIdentity)\r\n//                 && ((getMonthlyCounter(receiverIdentity, senderIdentity) + _value > _exchangeMonthlyLimit[receiverIdentity]))) {\r\n//                     return false;\r\n//                 }\r\n//             }\r\n//         }\r\n//         return true;\r\n//     }\r\n\r\n//     function _transferActionOnExchangeMonthlyLimits(address _from, address _to, uint256 _value) internal {\r\n//         address senderIdentity = _getIdentity(_from);\r\n//         address receiverIdentity = _getIdentity(_to);\r\n//         if(isExchangeID(receiverIdentity) && !isTokenAgent(_from)) {\r\n//             _increaseExchangeCounters(senderIdentity, receiverIdentity, _value);\r\n//         }\r\n//     }\r\n\r\n//     function _creationActionOnExchangeMonthlyLimits(address _to, uint256 _value) internal {}\r\n\r\n//     // solhint-disable-next-line no-empty-blocks\r\n//     function _destructionActionOnExchangeMonthlyLimits(address _from, uint256 _value) internal {}\r\n\r\n//     function _increaseExchangeCounters(address _exchangeID, address _investorID, uint256 _value) internal {\r\n//         _resetExchangeMonthlyCooldown(_exchangeID, _investorID);\r\n\r\n//         if ((getMonthlyCounter(_exchangeID, _investorID) + _value) <= _exchangeMonthlyLimit[_exchangeID]) {\r\n//             (_exchangeCounters[_exchangeID][_investorID]).monthlyCount += _value;\r\n//         }\r\n//     }\r\n\r\n//     function _resetExchangeMonthlyCooldown(address _exchangeID, address _investorID) internal {\r\n//         if (_isExchangeMonthFinished(_exchangeID, _investorID)) {\r\n//             (_exchangeCounters[_exchangeID][_investorID]).monthlyTimer = block.timestamp + 30 days;\r\n//             (_exchangeCounters[_exchangeID][_investorID]).monthlyCount = 0;\r\n//         }\r\n//     }\r\n\r\n//     function _isExchangeMonthFinished(address _exchangeID, address _investorID) internal view returns (bool) {\r\n//         return (getMonthlyTimer(_exchangeID, _investorID) <= block.timestamp);\r\n//     }\r\n\r\n\r\n// //MaxBalance functions\r\n\r\n//     function setMaxBalance(uint256 _max) external onlyOwner {\r\n//         maxBalance = _max;\r\n//         emit MaxBalanceSet(_max);\r\n//     }\r\n\r\n//     function complianceCheckOnMaxBalance (address /*_from*/, address _to, uint256 _value) public view returns (bool) {\r\n//         if (_value > maxBalance) {\r\n//             return false;\r\n//         }\r\n//         address _id = _getIdentity(_to);\r\n//         if ((IDBalance[_id] + _value) > maxBalance) {\r\n//             return false;\r\n//         }\r\n//         return true;\r\n//     }\r\n\r\n//     function _transferActionOnMaxBalance(address _from, address _to, uint256 _value) internal {\r\n//         address _idFrom = _getIdentity(_from);\r\n//         address _idTo = _getIdentity(_to);\r\n//         IDBalance[_idTo] += _value;\r\n//         IDBalance[_idFrom] -= _value;\r\n//         require (IDBalance[_idTo] <= maxBalance, \"post-transfer balance too high\");\r\n//     }\r\n\r\n//     function _creationActionOnMaxBalance(address _to, uint256 _value) internal {\r\n//         address _idTo = _getIdentity(_to);\r\n//         IDBalance[_idTo] += _value;\r\n//         require (IDBalance[_idTo] <= maxBalance, \"post-minting balance too high\");\r\n//     }\r\n\r\n//     function _destructionActionOnMaxBalance(address _from, uint256 _value) internal {\r\n//         address _idFrom = _getIdentity(_from);\r\n//         IDBalance[_idFrom] -= _value;\r\n//     }\r\n\r\n\r\n// //SuppliLimit Functions\r\n\r\n//     function setSupplyLimit(uint256 _limit) external onlyOwner {\r\n//         supplyLimit = _limit;\r\n//         emit SupplyLimitSet(_limit);\r\n//     }\r\n\r\n//     function complianceCheckOnSupplyLimit (address /*_from*/, address /*_to*/, uint256 /*_value*/)\r\n//     public view returns (bool) {\r\n//         return true;\r\n//     }\r\n\r\n//     function _transferActionOnSupplyLimit(address _from, address _to, uint256 _value) internal {}\r\n\r\n//     function _creationActionOnSupplyLimit(address /*_to*/, uint256 /*_value*/) internal {\r\n//         require(tokenBound.totalSupply() <= supplyLimit, \"cannot mint more tokens\");\r\n//     }\r\n\r\n//     function _destructionActionOnSupplyLimit(address _from, uint256 _value) internal {}\r\n\r\n// }\r\n"
			}
		},
		"settings": {
			"optimizer": {
				"enabled": true,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"metadata",
						"devdoc",
						"userdoc",
						"storageLayout",
						"evm.legacyAssembly",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"evm.gasEstimates",
						"evm.assembly"
					]
				}
			}
		}
	},
	"output": {
		"errors": [
			{
				"component": "general",
				"errorCode": "3420",
				"formattedMessage": "Warning: Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.17;\"\n--> Tokeny Project/Compliance/Compliance Rules/RulesCompliance.sol\n\n",
				"message": "Source file does not specify required compiler version! Consider adding \"pragma solidity ^0.8.17;\"",
				"severity": "warning",
				"sourceLocation": {
					"end": -1,
					"file": "Tokeny Project/Compliance/Compliance Rules/RulesCompliance.sol",
					"start": -1
				},
				"type": "Warning"
			}
		],
		"sources": {
			"Tokeny Project/Compliance/Compliance Rules/RulesCompliance.sol": {
				"ast": {
					"absolutePath": "Tokeny Project/Compliance/Compliance Rules/RulesCompliance.sol",
					"exportedSymbols": {},
					"id": 1,
					"license": "MIT",
					"nodeType": "SourceUnit",
					"nodes": [],
					"src": "14858:0:0"
				},
				"id": 0
			}
		}
	}
}